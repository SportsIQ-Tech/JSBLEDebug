<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KaiTag AR15 & GPS Map</title>
    <!-- Add Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
    <!-- Add Leaflet.draw CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"
     integrity="sha512-gc3xjCmIy673V6MyOAZhIW93xhM9ei1I+gLbmFjUHIjocENRsLX/QUE1htk5q1XV2D/iie/VQ8DXI6Vu8bexvQ==" 
     crossorigin="anonymous" referrerpolicy="no-referrer" />
        <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #fff; font-family: monospace; }
        #main-content {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%; /* Ensure width is also set */
        }
        #top-container {
            flex: 1; /* Take up remaining space */
            position: relative; /* For positioning button/status inside */
            overflow: hidden; /* Ensure canvas doesn't overflow */
            min-height: 50%; /* Minimum height */
            background: #fff; /* Set background to white for gun render area */
        }
        #bottom-container {
            flex: 1; /* Take up remaining space */
            min-height: 50%; /* Minimum height */
            border-top: 1px solid #555; /* Separator line */
            position: relative; /* Needed for absolute positioning of children */
        }
        #map {
             height: 100%;
             width: 100%;
             background-color: #333; /* Placeholder background */
        }
        /* Adjust canvas style if needed, Three.js usually handles this */
        #top-container canvas { display: block; }

        #gps-info { display: none; } /* Hide old GPS text */

        #connect-button {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            background-color: #444;
            border: none;
            border-radius: 5px;
            color: #fff;
            z-index: 10; /* Ensure button is on top of canvas */
        }
        #status {
             position: absolute;
             bottom: 10px;
             left: 10px;
             padding: 5px 10px;
             background-color: rgba(0, 0, 0, 0.5);
             border-radius: 5px;
             font-size: 14px;
             z-index: 10; /* Ensure status is on top of canvas */
        }

        /* Team Selection Overlay */
        #team-selection-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top of everything */
            color: #fff;
            font-size: 24px;
        }
        #team-selection-overlay button {
            font-size: 20px;
            padding: 15px 30px;
            margin: 20px;
            cursor: pointer;
            border: 2px solid;
            border-radius: 8px;
            color: #fff;
            background-color: transparent;
            transition: background-color 0.3s, color 0.3s;
        }
        #team-red-button {
            border-color: #ff4d4d;
        }
        #team-red-button:hover {
            background-color: #ff4d4d;
        }
        #team-blue-button {
            border-color: #4da6ff;
        }
        #team-blue-button:hover {
            background-color: #4da6ff;
        }
        .hidden {
             display: none !important;
        }
        /* Custom DivIcon styles */
        .leaflet-div-icon {
            background: transparent;
            border: none;
        }
        .player-marker {
            text-align: center;
            font-weight: bold;
            line-height: 16px;
            font-size: 18px;
        }
        .player-marker-circle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid black;
        }
        .player-marker-x {
             /* Style for the X marker */
             width: 16px; /* Match circle size */
             height: 16px;
             line-height: 16px; /* Vertically center X */
        }
        /* Drawing Buttons */
        #draw-button, #clear-drawings-button {
            position: absolute;
            top: 10px; /* Position from top of bottom-container */
            padding: 8px 12px;
            font-size: 14px;
            cursor: pointer;
            background-color: #555;
            border: none;
            border-radius: 5px;
            color: #fff;
            z-index: 400; /* Ensure above map tiles but below modals */
        }
        #draw-button {
            right: 10px; /* Position on the right */
        }
        #clear-drawings-button {
            right: 140px; /* Position to the left of draw-button */
        }
        </style>
    </head>
    <body>
    <!-- Move containers inside a main wrapper -->
    <div id="main-content" class="hidden">
        <div id="top-container">
            <!-- Connect button and status moved inside top container -->
            <button id="connect-button">Connect KaiTag</button>
            <button id="toggle-preview-button">Hide/Show Gun Preview</button>
            <div id="status">Status: Disconnected</div>
            <!-- Canvas will be added here by Three.js -->
        </div>
        <div id="bottom-container">
            <div id="map"></div>
            <button id="draw-button">Start Drawing</button>
            <button id="clear-drawings-button">Clear Drawings</button>
        </div>
    </div>

    <!-- Team Selection Overlay -->
    <div id="team-selection-overlay">
        <h2>Choose Your Team</h2>
        <div>
            <button id="team-red-button">Join Team Red</button>
            <button id="team-blue-button">Join Team Blue</button>
        </div>
    </div>

    <!-- Old GPS Info Div (hidden by CSS) -->
    <div id="gps-info">GPS: Acquiring...</div>

     <!-- Add Leaflet JS -->
     <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>
    <!-- Add Leaflet.draw JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"
     integrity="sha512-ozq8xQKq6urvuU6jNgkfqAmT7jKN2XumbrX1JiB3TnF7tI48DPI4Gy1GXKD/V3EExgAs1V+pRO7vwtS1LHg0Gw=="
     crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <!-- Add Socket.IO Client Library -->
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"
    integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO"
    crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Constants ---
        const SERVICE_UUID = 'b7063e97-8504-4fcb-b0f5-aef2d5903c4d';
        const QUATERNION_CHARACTERISTIC_UUID = '71fa0f31-bcc7-42f2-bb57-a9810b436231';

        // --- DOM Elements ---
        // const gpsInfoDiv = document.getElementById('gps-info'); // No longer used directly
        const mainContentDiv = document.getElementById('main-content');
        const teamOverlayDiv = document.getElementById('team-selection-overlay');
        const teamRedButton = document.getElementById('team-red-button');
        const teamBlueButton = document.getElementById('team-blue-button');
        const connectButton = document.getElementById('connect-button');
        const statusDiv = document.getElementById('status');
        const topContainer = document.getElementById('top-container');
        const mapContainer = document.getElementById('map');
        const togglePreviewButton = document.getElementById('toggle-preview-button');
        const drawButton = document.getElementById('draw-button');
        const clearDrawingsButton = document.getElementById('clear-drawings-button');

        // --- State ---
        let device = null;
        let quaternionCharacteristic = null;
        let ar15Model = null;
        let scene = null;
        let camera = null;
        let renderer = null;
        const targetQuaternion = new THREE.Quaternion();
        const displayQuaternion = new THREE.Quaternion();
        let map = null; // Leaflet map instance
        let localGpsMarker = null; // Leaflet marker instance for the LOCAL user
        let otherClientMarkers = {}; // { clientId: { marker: L.Marker, line: L.Polyline }, ... }
        let firstGpsUpdate = true;
        const lineDistanceMeters = 500; // How long the direction line should be
        const forwardVector = new THREE.Vector3(); // Reusable vector for direction calculation
        let socket = null; // Socket.IO client instance
        let myClientId = null;
        let clientStates = {}; // { clientId: { lat, lon, bearing, timestamp, team, kaiTagConnected }, ... }
        let myTeam = null; // 'red' or 'blue'
        let localKaiTagConnected = false; // Track local device connection status
        let reconnectIntervalId = null; // Timer ID for auto-reconnect attempts
        const RECONNECT_DELAY = 5000; // 5 seconds
        let localIsDead = false;
        const deadPitchThreshold = -55 * (Math.PI / 180); // Below -75 degrees pitch = dead (radians)
        const euler = new THREE.Euler(); // Reusable Euler for pitch calculation

        // Drawing State
        let drawnItems = null; // FeatureGroup for local drawings
        let receivedDrawingItems = null; // FeatureGroup for remote drawings
        let drawControl = null; // Leaflet Draw control instance
        let currentPolylineDrawer = null; // Reference to the active drawing handler
        let localDrawingLayer = null; // The currently drawn local layer before sharing

        // Throttling for bearing updates
        let lastBearingSendTime = 0;
        let lastSentBearing = -1; // Initialize to impossible value
        const bearingUpdateThreshold = 1.0; // Degrees
        const bearingUpdateInterval = 100; // Milliseconds (10 times per second max)

        // --- Helper: Send Full State Update ---
        function sendFullStateUpdate() {
            if (!myTeam || !myClientId || !socket || !socket.connected) return; // Need team, ID, and connection

            // Try to get current GPS coords, use last known if unavailable directly
            let lat = 0, lon = 0;
            if (clientStates[myClientId] && clientStates[myClientId].lat !== undefined) {
                lat = clientStates[myClientId].lat;
                lon = clientStates[myClientId].lon;
            }
            // TODO: Consider getting fresh GPS coords here if possible/needed

            const statePayload = {
                lat: lat,
                lon: lon,
                bearing: getLocalBearing(), // Get current bearing
                team: myTeam,
                isDead: localIsDead, // Include dead status
                kaiTagConnected: localKaiTagConnected // Include connection status
            };
            sendSocketIOMessage('update_state', statePayload);

            // Update local state immediately
            if (!clientStates[myClientId]) clientStates[myClientId] = {};
            Object.assign(clientStates[myClientId], statePayload);
            clientStates[myClientId].timestamp = Date.now();
            updateMapMarkers(); // Update map immediately
            // console.log("Sent full state update:", statePayload);
        }

        // --- Socket.IO Communication ---
        function connectSocketIO() {
             // Connect to the Socket.IO server (same origin)
             socket = io(); // If server is elsewhere: io('http://server.com:port');

             socket.on('connect', () => {
                 console.log('Socket.IO Connected, SID:', socket.id);
                 statusDiv.textContent = 'Status: Connected';
                 // Client ID is now socket.id, but wait for 'your_id' message
                 // just in case server uses a different ID system
             });

             socket.on('disconnect', (reason) => {
                 console.log('Socket.IO Disconnected:', reason);
                 statusDiv.textContent = 'Status: Disconnected';
                 myClientId = null;
                 // Clear other clients from map
                 Object.values(otherClientMarkers).forEach(({ marker, line }) => {
                     if (map && marker) map.removeLayer(marker);
                     if (map && line) map.removeLayer(line);
                 });
                 otherClientMarkers = {};
                 clientStates = {};
             });

             socket.on('connect_error', (error) => {
                 console.error('Socket.IO Connection Error:', error);
                 statusDiv.textContent = 'Status: Connection Error';
             });

             // --- Custom Event Handlers ---
             socket.on('your_id', (id) => {
                 myClientId = id;
                 console.log('My Client ID:', myClientId);
             });

             socket.on('all_states', (states) => {
                 // console.log('Received all_states:', states);
                 clientStates = states;
                 updateMapMarkers(); // Redraw map based on new states
             });

             socket.on('client_disconnected', (disconnectedId) => {
                  console.log(`Client disconnected event: ${disconnectedId}`);
                  // Remove the specific client (map update handled by 'all_states' usually,
                  // but we can explicitly remove here too for faster feedback)
                  if (otherClientMarkers[disconnectedId]) {
                     if(map && otherClientMarkers[disconnectedId].marker) map.removeLayer(otherClientMarkers[disconnectedId].marker);
                     if(map && otherClientMarkers[disconnectedId].line) map.removeLayer(otherClientMarkers[disconnectedId].line);
                     delete otherClientMarkers[disconnectedId];
                     console.log(`Removed disconnected client ${disconnectedId} marker/line`);
                  }
                  // State update will come via next 'all_states' broadcast
             });

             socket.on('bearing_updated', (update) => {
                 // console.log('Received bearing_updated:', update);
                 const { clientId, bearing, timestamp } = update;
                 if (clientStates[clientId]) {
                     clientStates[clientId].bearing = bearing;
                     clientStates[clientId].timestamp = timestamp; // Use server timestamp
                     // Update map (could optimize to only update the specific client's line)
                     updateMapMarkers();
                 } else {
                     console.warn('Received bearing update for unknown client:', clientId);
                     // Request full state? Or wait for next all_states broadcast.
                 }
             });

             socket.on('new_drawing', (drawingData) => {
                 console.log(`[Socket Event] Received 'new_drawing'`, drawingData);
                 if (!drawingData || !drawingData.geojson || !drawingData.clientId || !drawingData.team) {
                     console.warn("Received incomplete drawing data.", drawingData);
                     return;
                 }
                 const { geojson, clientId, team } = drawingData;
                 const isTeammate = (clientId !== myClientId && team === myTeam);
                 console.log(` -> Drawing from: ${clientId}, Team: ${team}. Is Teammate: ${isTeammate}`);

                 if (isTeammate) { // Only show drawings from teammates
                     try {
                         const layer = L.geoJSON(geojson, {
                             style: function(feature) {
                                 let color = (team === 'red') ? "#ff8080" : "#8080ff"; // Lighter team colors
                                 return { color: color, weight: 3, opacity: 0.8 };
                             }
                         });
                         if (receivedDrawingItems) {
                              receivedDrawingItems.addLayer(layer);
                              console.log(` -> Added drawing from ${clientId} to receivedDrawingItems group.`);
                         } else {
                             console.error("receivedDrawingItems layer group not initialized when trying to add layer!");
                         }
                     } catch (e) {
                         console.error("Error creating or adding GeoJSON layer:", e, geojson);
                     }
                  } else {
                      console.log(' -> Ignoring own drawing or drawing from different team');
                  }
             });
         }

        function sendSocketIOMessage(type, payload) {
            if (socket && socket.connected) {
                // console.log('Emitting Socket.IO message:', type, payload);
                socket.emit(type, payload);
            } else {
                console.warn('Socket.IO not connected. Message not sent:', type);
            }
        }

        // --- Helper: Calculate Destination Point ---
        function calculateDestinationPoint(lat1, lon1, bearing, distance) {
            const R = 6371e3; // Earth radius in meters
            const phi1 = lat1 * Math.PI / 180; // φ, λ in radians
            const lambda1 = lon1 * Math.PI / 180;
            const brng = bearing * Math.PI / 180;
            const d = distance;

            const phi2 = Math.asin(Math.sin(phi1) * Math.cos(d / R) +
                                 Math.cos(phi1) * Math.sin(d / R) * Math.cos(brng));
            const lambda2 = lambda1 + Math.atan2(Math.sin(brng) * Math.sin(d / R) * Math.cos(phi1),
                                           Math.cos(d / R) - Math.sin(phi1) * Math.sin(phi2));

            const lat2 = phi2 * 180 / Math.PI;
            const lon2 = lambda2 * 180 / Math.PI;

            return [lat2, lon2];
        }

        // --- Helper: Get Local Bearing ---
        function getLocalBearing() {
             if (!ar15Model) return 0; // Default bearing

            // 1. Get Gun's World Direction
            ar15Model.getWorldDirection(forwardVector); // Updates forwardVector

            // 2. Calculate Azimuth
            const azimuth = Math.atan2(forwardVector.x, forwardVector.z);

            // 3. Convert Azimuth to Bearing
            let bearing = azimuth * (180 / Math.PI);
            bearing = (bearing + 360) % 360; // Normalize to 0-359 degrees
            // Adjust bearing offset if needed here based on model orientation vs North
            return bearing;
        }

        // --- Helper: Update Map Markers and Lines (All Clients) ---
        function updateMapMarkers() {
            if (!map || !myClientId) return; // Need map and our ID

            const currentOtherIds = new Set(Object.keys(otherClientMarkers));

            for (const clientId in clientStates) {
                const state = clientStates[clientId];
                // Skip if state is incomplete (might happen briefly on connect/disconnect)
                if (typeof state.lat !== 'number' || typeof state.lon !== 'number') continue;

                const latLng = L.latLng(state.lat, state.lon);
                const endPointLatLng = calculateDestinationPoint(state.lat, state.lon, state.bearing, lineDistanceMeters);
                const isLocal = (clientId === myClientId);
                const team = state.team || 'blue';
                const isKaiTagConnected = state.kaiTagConnected !== undefined ? state.kaiTagConnected : true; // Default to true if unknown

                // --- Team Filtering Logic ---
                if (!isLocal && team !== myTeam) {
                    // If this client is not the local player AND not on the same team, skip drawing/updating
                    // But make sure we mark it as seen if it was previously drawn, so it gets removed later if needed.
                    currentOtherIds.delete(clientId);
                    continue; // Skip to the next client
                }

                const isDead = state.isDead || false;
                const isConnected = state.kaiTagConnected !== undefined ? state.kaiTagConnected : true;

                // Determine colors
                let markerColor;
                if (!isConnected && !isLocal) {
                    markerColor = "#808080"; // Gray for disconnected non-local players
                } else {
                    markerColor = (team === 'red') ? "#ff0000" : "#0000ff"; // Team color otherwise
                }
                let lineColor = markerColor;
                let popupText = `Team ${team.charAt(0).toUpperCase() + team.slice(1)} (${clientId.substring(0, 6)})`;
                if (!isConnected && !isLocal) {
                    popupText += " (Disconnected)";
                }
                if (isDead) {
                    popupText += " (Dead)";
                }

                if (isLocal) {
                    markerColor = "#00ff00"; // Always green for local player
                    lineColor = markerColor; // Use marker color (green)
                    popupText = "You";
                    if (localIsDead) { popupText += " (Dead)"; }

                    // Update local marker and line (create if they don't exist)
                    if (!localGpsMarker) {
                        localGpsMarker = L.marker(latLng, {
                            icon: createMarkerIcon(true, localIsDead, true, myTeam)
                        }).addTo(map).bindPopup(popupText);

                        localGpsMarker.directionLine = L.polyline([], { // Start empty
                            color: lineColor, weight: 3
                        }).addTo(map);
                    } else {
                        localGpsMarker.setLatLng(latLng);
                        // Update style if marker exists but color needs changing (unlikely for local)
                        localGpsMarker.setIcon(createMarkerIcon(true, localIsDead, true, myTeam));
                        localGpsMarker.directionLine.setStyle({ color: lineColor });
                        localGpsMarker.setPopupContent(popupText);
                    }
                    // Update or hide local line based on dead status
                    if (localIsDead || !isConnected) {
                        localGpsMarker.directionLine.setLatLngs([]); // Empty the line
                    } else {
                        localGpsMarker.directionLine.setLatLngs([latLng, endPointLatLng]);
                    }

                    // Center map on first update, pan on subsequent updates
                    if (firstGpsUpdate) {
                        map.setView(latLng, 30); // Zoom in on first update
                        firstGpsUpdate = false;
                        console.log("Local GPS Acquired, centering map.");
                    } else {
                        map.panTo(latLng); // Pan smoothly to new location
                    }

                } else {
                    // Update other client marker and line
                    if (otherClientMarkers[clientId]) {
                        // Existing other client
                        otherClientMarkers[clientId].marker.setLatLng(latLng);
                        otherClientMarkers[clientId].marker.setIcon(createMarkerIcon(false, isDead, isConnected, team));
                        otherClientMarkers[clientId].marker.setPopupContent(popupText);
                        otherClientMarkers[clientId].line.setStyle({ color: lineColor });
                        // Update or hide remote line
                        if (isDead || !isConnected) {
                            otherClientMarkers[clientId].line.setLatLngs([]);
                        } else {
                            otherClientMarkers[clientId].line.setLatLngs([latLng, endPointLatLng]);
                        }
                    } else {
                        // New other client
                        const marker = L.marker(latLng, {
                            icon: createMarkerIcon(false, isDead, isConnected, team)
                        }).addTo(map).bindPopup(popupText);

                        const line = L.polyline([latLng, endPointLatLng], {
                            color: lineColor, weight: 3
                        }).addTo(map);
                        // Hide line initially if dead/disconnected
                        if (isDead || !isConnected) {
                            line.setLatLngs([]);
                        }
                        otherClientMarkers[clientId] = { marker, line };
                        console.log(`Added other client ${clientId} to map`);
                    }
                    currentOtherIds.delete(clientId); // Mark this ID as still present
                }
            }

             // Remove markers for clients that are no longer in clientStates
            currentOtherIds.forEach(clientIdToRemove => {
                if (otherClientMarkers[clientIdToRemove]) {
                    map.removeLayer(otherClientMarkers[clientIdToRemove].marker);
                    map.removeLayer(otherClientMarkers[clientIdToRemove].line);
                    delete otherClientMarkers[clientIdToRemove];
                    console.log(`Removed stale client ${clientIdToRemove} from map`);
                }
            });
        }

        // --- 3D Setup ---
        function initThreeJS() {
            scene = new THREE.Scene();

            // Get dimensions of the top container
            const width = topContainer.clientWidth;
            const height = topContainer.clientHeight;

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(0xffffff, 1); // Set background to white
            renderer.setSize(width, height);
            topContainer.appendChild(renderer.domElement); // Append canvas to top container

            // Lighting (Increased intensity)
            const ambientLight = new THREE.AmbientLight(0x404040, 3);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight2.position.set(-1, -1, -1).normalize();
            scene.add(directionalLight2);

            // Load AR15 Model
            const loader = new GLTFLoader();
            const modelPath = 'models/ar15.glb';
            loader.load(
                modelPath,
                function (gltf) {
                    ar15Model = gltf.scene;
                    console.log(`Loaded ${modelPath}`);
                    // Adjust scale and position
                    ar15Model.scale.set(10, 10, 10); // Scale from previous step
                    ar15Model.position.set(0, 0, 0);
                    scene.add(ar15Model);
                    console.log('Model added to scene.');
                },
                undefined,
                function (error) {
                    console.error(`Error loading ${modelPath}:`, error);
                    statusDiv.textContent = `Status: Error loading 3D model! Check console.`;
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = new THREE.MeshStandardMaterial({color: 0xdddddd});
                    ar15Model = new THREE.Mesh(geometry, material);
                    scene.add(ar15Model);
                    console.log('Placeholder cube added due to load error.');
                }
            );

            camera.position.z = 10; // Keep camera distance
            console.log('Camera position:', camera.position);

            animate();
            // Note: Resize handled by global window resize listener
        }

        // --- Map Setup ---
        function initMap() {
            const initialCoords = [0, 0];
            map = L.map(mapContainer).setView(initialCoords, 2);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map);

            // Markers and lines are now created/updated dynamically in updateMapMarkers
            console.log("Map initialized");
        }

        function onWindowResize() {
             // Update 3D view
             if (camera && renderer && topContainer) {
                const width = topContainer.clientWidth;
                const height = topContainer.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
                console.log("Resized 3D view");
             }

            // Update map view
            if (map) {
                map.invalidateSize(); // Recalculate map size
                console.log("Resized map view");
            }
        }
        window.addEventListener('resize', onWindowResize, false);

        function animate() {
            requestAnimationFrame(animate);

            let modelRotated = false;
            let wasDead = localIsDead; // Track previous dead state
            let currentBearing = 0;
            if (ar15Model) {
                // Smoothly interpolate the model's rotation
                displayQuaternion.slerp(targetQuaternion, 0.1);
                // Apply base rotation if needed (adjust based on your model)
                const baseOrientation = new THREE.Quaternion() //.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);
                const finalQuaternion = baseOrientation.multiply(displayQuaternion);
                ar15Model.setRotationFromQuaternion(finalQuaternion);
                modelRotated = true;
                currentBearing = getLocalBearing(); // Get bearing after rotation

                // --- Dead State Check ---
                euler.setFromQuaternion(displayQuaternion, 'YXZ'); // Use display quat, YXZ order common
                const pitch = euler.x; // Pitch around X axis
                localIsDead = (pitch < deadPitchThreshold);
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }

            // Update LOCAL direction line directly based on latest bearing
            let localLineUpdated = false;
            if (modelRotated && localGpsMarker && localGpsMarker.directionLine) {
                const startPoint = localGpsMarker.getLatLng();
                if (startPoint) { // Ensure we have a valid LatLng
                    const endPointLatLng = calculateDestinationPoint(startPoint.lat, startPoint.lng, currentBearing, lineDistanceMeters);
                    // Only show line if NOT dead and connected
                    if (!localIsDead && localKaiTagConnected) {
                        localGpsMarker.directionLine.setLatLngs([ [startPoint.lat, startPoint.lng], endPointLatLng ]);
                    } else {
                        localGpsMarker.directionLine.setLatLngs([]); // Hide line
                    }
                    // Update marker icon if dead state changed
                    if (wasDead !== localIsDead) {
                        localGpsMarker.setIcon(createMarkerIcon(true, localIsDead, true, myTeam));
                        // Send update immediately if dead state changed
                        sendFullStateUpdate();
                    }
                }
            }

            // Throttle sending bearing updates via Socket.IO
            const now = Date.now();
            const bearingChanged = Math.abs(currentBearing - lastSentBearing) > bearingUpdateThreshold || lastSentBearing < 0;
            const deadStateChanged = wasDead !== localIsDead;
            const enoughTimePassed = now - lastBearingSendTime > bearingUpdateInterval;

            if (modelRotated && socket && socket.connected && myClientId &&
                enoughTimePassed && (bearingChanged || deadStateChanged) ) // Send if time passed AND (bearing changed OR dead state changed)
            {
                // Send the FULL state, as it includes the isDead flag
                sendFullStateUpdate();
                lastSentBearing = currentBearing;
                lastBearingSendTime = now;
                // console.log(`Sent bearing update: ${currentBearing.toFixed(1)}`);
            }
        }

        // --- GPS ---
        function initGPS() {
            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(
                    (position) => {
                        const timestamp = new Date(position.timestamp).toISOString();
                        const lat = position.coords.latitude;
                        const lon = position.coords.longitude;
                        const accuracy = position.coords.accuracy;
                        console.log(`[${timestamp}] GPS Update: Lat=${lat.toFixed(6)}, Lon=${lon.toFixed(6)}, Accuracy=${accuracy ? accuracy.toFixed(1)+'m' : 'N/A'}`);

                        // Update local state first (for sendFullStateUpdate)
                        if(myClientId) {
                             if (!clientStates[myClientId]) clientStates[myClientId] = {};
                             clientStates[myClientId].lat = lat;
                             clientStates[myClientId].lon = lon;
                        }

                        // Center map on first update, pan on subsequent updates
                        if (map && localGpsMarker) {
                            const latLng = L.latLng(lat, lon); // Create LatLng object
                            // Set view (center and zoom) on all updates
                            const targetZoom = 30; // Keep the zoom level constant
                            map.setView(latLng, targetZoom);
                            if (firstGpsUpdate) {
                                 console.log("Local GPS Acquired, centering map.");
                                 firstGpsUpdate = false; // Still track first update for logging
                            }
                        }

                        // Only send update if a team has been selected
                        if (myTeam) {
                            // Send full state (includes kaiTagConnected status) on GPS update
                            sendFullStateUpdate();
                        } else {
                            console.log("GPS Update received, but no team selected yet.")
                        }
                    },
                    (error) => {
                        // Log GPS errors
                        const timestamp = new Date().toISOString();
                        console.error(`[${timestamp}] Geolocation error:`, error.message, error.code);
                        statusDiv.textContent = `Status: GPS Error - ${error.message}`;
                    },
                    {
                        enableHighAccuracy: true, // Keep high accuracy
                        maximumAge: 0,         // Request fresh position every time
                        timeout: 10000         // Give up after 10s
                    }
                );
            } else {
                statusDiv.textContent = "Status: GPS not supported";
                console.error("Geolocation not supported by this browser.");
            }
        }

        // --- BLE ---
        function stopReconnectTimer() {
            if (reconnectIntervalId !== null) {
                console.log("Stopping KaiTag reconnect timer.");
                clearInterval(reconnectIntervalId);
                reconnectIntervalId = null;
            }
        }

        async function connectDevice() {
            const isManualAttempt = reconnectIntervalId === null; // Check if this is a manual click or auto-reconnect
            try {
                // Stop trying to reconnect if we manually click connect again
                if (isManualAttempt) {
                    stopReconnectTimer();
                }

                if (!isManualAttempt) {
                    statusDiv.textContent = 'Status: Reconnecting KaiTag...';
                    console.log("Attempting automatic KaiTag reconnect...");
                    // For auto-reconnect, we assume we already have the 'device' object.
                    if (!device) {
                        console.error("Reconnect timer running but device object is null. Stopping timer.");
                        stopReconnectTimer();
                        return;
                    }
                    // Add a specific check for gatt being connected already, stop timer if so
                    if (device.gatt && device.gatt.connected) {
                        console.log("Device already connected, stopping reconnect timer.");
                        stopReconnectTimer();
                        return;
                    }
                } else {
                    statusDiv.textContent = 'Status: Requesting device...';
                    // Manual connection: request the device
                    const requestedDevice = await navigator.bluetooth.requestDevice({
                        filters: [{name: 'KaiTag'}],
                        optionalServices: [SERVICE_UUID]
                    });
                    device = requestedDevice; // Store the device object
                }

                device.removeEventListener('gattserverdisconnected', onDisconnected); // Remove previous listener if any
                device.addEventListener('gattserverdisconnected', onDisconnected);
                const server = await device.gatt.connect();
                stopReconnectTimer(); // Stop trying if connection succeeds
                statusDiv.textContent = 'Status: Getting Service...';
                const service = await server.getPrimaryService(SERVICE_UUID);
                statusDiv.textContent = 'Status: Getting Characteristic...';
                quaternionCharacteristic = await service.getCharacteristic(QUATERNION_CHARACTERISTIC_UUID);
                statusDiv.textContent = 'Status: Starting Notifications...';
                await quaternionCharacteristic.startNotifications();
                quaternionCharacteristic.addEventListener('characteristicvaluechanged', handleCharacteristicValueChanged);
                statusDiv.textContent = `Status: Connected to ${device.name}`;
                connectButton.textContent = 'Disconnect';
                console.log('Connected to KaiTag');
                localKaiTagConnected = true;
                sendFullStateUpdate(); // Send updated state with connection status

            } catch (error) {
                // Log different message based on attempt type
                const errorMsg = isManualAttempt ? 'Manual BLE Connection Error:' : 'Auto-Reconnect BLE Error:';
                statusDiv.textContent = `Status: Error - ${error.message}`;
                console.error(errorMsg, error);
                localKaiTagConnected = false; // Ensure status is false on error

                if (isManualAttempt) {
                    // Reset button etc. only on manual connect failure
                    if (device && device.gatt.connected) {
                        try { device.gatt.disconnect(); } catch (e) { console.warn("Error during disconnect on failure:", e); }
                    }
                    device = null;
                    quaternionCharacteristic = null;
                    connectButton.textContent = 'Connect KaiTag';
                } else {
                    // Auto-reconnect failed, timer will try again unless stopped
                    console.log("Auto-reconnect attempt failed. Will retry.");
                }
                // Send state update even on failure if we have an ID/team
                sendFullStateUpdate();
            }
        }

        function onDisconnected() {
            statusDiv.textContent = 'Status: KaiTag Disconnected';
            console.log('KaiTag device disconnected');
            localKaiTagConnected = false;
            if (quaternionCharacteristic) {
                quaternionCharacteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicValueChanged);
                quaternionCharacteristic = null; // Clear characteristic
            }
            // Keep the device object for reconnect attempts
            // Send state update immediately
            sendFullStateUpdate();

            // Start automatic reconnection attempts if not already running
            if (reconnectIntervalId === null) {
                console.log(`Starting KaiTag auto-reconnect attempts every ${RECONNECT_DELAY}ms`);
                reconnectIntervalId = setInterval(() => {
                    if (device && (!device.gatt || !device.gatt.connected)) { // Only try if device exists and not connected
                       connectDevice(); // Call connectDevice which handles reconnect logic
                    } else if (!device) {
                        console.warn("Reconnect timer active but no device object. Stopping timer.");
                        stopReconnectTimer();
                    } else { // Already connected
                         console.log("Reconnect timer: Device appears connected. Stopping timer.");
                         stopReconnectTimer(); // Stop timer if already connected
                    }
                }, RECONNECT_DELAY);
            }
        }

        async function disconnectDevice() { // Manual disconnect
            stopReconnectTimer(); // Stop any auto-reconnect attempts first
            if (!device || !device.gatt.connected) {
                 connectButton.textContent = 'Connect KaiTag'; // Ensure button is correct state
                 // Also update local state and notify server
                 localKaiTagConnected = false;
                 sendFullStateUpdate();
                 return;
            }

            statusDiv.textContent = 'Status: Disconnecting...';
            try {
                if (quaternionCharacteristic && quaternionCharacteristic.properties.notify) {
                    await quaternionCharacteristic.stopNotifications();
                    quaternionCharacteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicValueChanged);
                     console.log('Stopped characteristic notifications.');
                 }
                device.gatt.disconnect(); // onDisconnected will handle the rest
            } catch(error) {
                statusDiv.textContent = `Status: Error disconnecting - ${error.message}`;
                console.error('BLE Disconnect Error:', error);
                onDisconnected();
            }
        }

        function handleCharacteristicValueChanged(event) {
            const value = event.target.value;
             if (value.byteLength >= 16) {
                 try {
                    const w = value.getFloat32(0, true);
                    const x = value.getFloat32(4, true);
                    const y = value.getFloat32(8, true);
                    const z = value.getFloat32(12, true);
                     targetQuaternion.set(x, y, z, w).normalize();
                 } catch (e) {
                     console.error("Error parsing quaternion data:", e);
                 }
            } else {
                 console.warn(`Received data length ${value.byteLength} is less than expected 16 bytes for quaternion.`);
             }
        }

        // --- Event Listeners ---
        function handleTeamSelection(selectedTeam) {
            console.log('handleTeamSelection called with:', selectedTeam);
            console.log('Overlay Element:', teamOverlayDiv);
            console.log('Main Content Element:', mainContentDiv);
             myTeam = selectedTeam;
             console.log(`Team selected: ${myTeam}`);
             teamOverlayDiv.classList.add('hidden');
             mainContentDiv.classList.remove('hidden');

             // Force map and canvas resize after showing the main content
             // Use setTimeout to ensure the browser has rendered the layout changes
             setTimeout(() => {
                 console.log("Forcing resize after team selection...");
                 onWindowResize();
             }, 0); // Delay of 0 ms is often enough

             // Trigger initial state update if GPS is already running
             // (but usually initGPS will handle the first update)
             // You could potentially force an update here if needed:
             // if (navigator.geolocation...) forceGPSUpdate();
        }

        // Ensure elements exist before adding listeners (though placement should be fine)
        if (teamRedButton && teamBlueButton) {
             teamRedButton.addEventListener('click', () => handleTeamSelection('red'));
             teamBlueButton.addEventListener('click', () => handleTeamSelection('blue'));
             console.log("Team selection button listeners attached.");
        } else {
             console.error("Could not find team selection buttons!");
        }

        connectButton.addEventListener('click', () => {
            if (device && device.gatt.connected) {
                disconnectDevice();
            } else {
                connectDevice();
            }
        });

        // Add listener for the toggle preview button
        togglePreviewButton.addEventListener('click', () => {
            topContainer.classList.toggle('hidden');
            togglePreviewButton.textContent = topContainer.classList.contains('hidden') ? 'Show Gun Preview' : 'Hide Gun Preview';
            // Ensure map resizes correctly after top container is hidden/shown
            if (map) {
                map.invalidateSize();
            }
        });

        // Listener for the Draw/Share button
        drawButton.addEventListener('click', () => {
            if (!drawControl) {
                console.error("Draw control not initialized!");
                return;
            }

            if (!currentPolylineDrawer) {
                // Start Drawing
                currentPolylineDrawer = new L.Draw.Polyline(map, drawControl.options.draw.polyline);
                currentPolylineDrawer.enable();
                drawButton.textContent = 'Share Drawing';
                console.log("Drawing mode enabled.");
            } else {
                // Share Drawing / Cancel Drawing
                currentPolylineDrawer.disable(); // Disable the drawing handler
                currentPolylineDrawer = null;

                if (localDrawingLayer) {
                    // Send the drawing
                    const geojson = localDrawingLayer.toGeoJSON();
                    const payload = {
                        geojson: geojson,
                        team: myTeam
                    };
                    console.log("[Socket Event] Sending 'share_drawing' with payload:", payload);
                    if (!payload.team) {
                         console.warn("Attempting to send drawing without team selected!");
                    }
                    sendSocketIOMessage('share_drawing', payload);
                    // Optionally clear local drawing after sharing, or keep it.
                    // --- Reverting: Keep local drawing after sharing ---
                    // if (drawnItems && localDrawingLayer) {
                    //     drawnItems.removeLayer(localDrawingLayer);
                    //     console.log("Removed local drawing layer after sharing.");
                    // }
                    // localDrawingLayer = null; // Clear reference
                    // --- End Revert ---
                     drawButton.textContent = 'Start Drawing'; // Reset button
                     // Keeping local drawing visible after share.
                } else {
                    // No drawing was created, just cancelled
                    drawButton.textContent = 'Start Drawing';
                    console.log("Drawing mode cancelled.");
                }
            }
        });

        // Listener for the Clear Drawings button
        clearDrawingsButton.addEventListener('click', () => {
            let clearedCount = 0;
            if (receivedDrawingItems) {
                const layerCount = receivedDrawingItems.getLayers().length;
                console.log(`Clearing received drawings. Layer count before: ${layerCount}`);
                receivedDrawingItems.clearLayers(); // Clear received drawings
                clearedCount += layerCount;
                console.log(`Cleared received drawings.`);
            } else {
                console.warn("receivedDrawingItems group not found!");
            }
            // Also clear local drawing
            if (drawnItems) {
                const localLayerCount = drawnItems.getLayers().length;
                console.log(`Clearing local drawing. Layer count before: ${localLayerCount}`);
                 drawnItems.clearLayers(); // Clear local drawings group
                 clearedCount += localLayerCount;
                 localDrawingLayer = null; // Reset the reference to the current local drawing
                 console.log(`Cleared local drawing.`);
            } else {
                console.warn("drawnItems group not found!");
            }
             console.log(`Total drawings cleared: ${clearedCount}`);
        });

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded and parsed");
            initMap();
            initializeDrawing(); // Initialize drawing controls after map
            initThreeJS();
            initGPS();
            connectSocketIO(); // Connect Socket.IO after setting up UI
        });

        // --- Helper: Create Marker Icon ---
        function createMarkerIcon(isLocal, isDead, isConnected, team) {
            let iconHtml = '';
            let color = '#808080'; // Default gray

            if (isLocal) {
                color = '#00ff00'; // Green for local
            } else if (isConnected) {
                color = (team === 'red') ? '#ff0000' : '#0000ff'; // Team color if connected
            } // else stick with gray for disconnected

            if (isDead) {
                // X marker
                iconHtml = `<div class="player-marker player-marker-x" style="color: ${color};">X</div>`;
            } else {
                // Circle marker
                iconHtml = `<div class="player-marker player-marker-circle" style="background-color: ${color};"></div>`;
            }

            return L.divIcon({
                html: iconHtml,
                className: 'leaflet-div-icon', // Base class, styling done inline/via specific classes
                iconSize: [16, 16],
                iconAnchor: [8, 8] // Center the icon
            });
        }

        // --- Drawing Handlers ---
        function initializeDrawing() {
            drawnItems = new L.FeatureGroup().addTo(map);
            receivedDrawingItems = new L.FeatureGroup().addTo(map);

            drawControl = new L.Control.Draw({
                edit: { featureGroup: drawnItems }, // Allow editing local drawings (optional)
                draw: {
                    polyline: {
                        shapeOptions: {
                            color: '#f357a1', // Pink color for drawing
                            weight: 4
                        }
                    },
                    // Disable other drawing tools
                    polygon: false,
                    rectangle: false,
                    circle: false,
                    marker: false,
                    circlemarker: false
                }
            });
            // Don't add the control toolbar to the map directly
            // map.addControl(drawControl);

            map.on(L.Draw.Event.CREATED, function (event) {
                const layer = event.layer;
                // Clear previous local drawing before adding new one
                if (localDrawingLayer) {
                    drawnItems.removeLayer(localDrawingLayer);
                }
                localDrawingLayer = layer; // Store the new drawing
                drawnItems.addLayer(layer);
                console.log("Drawing created locally.");
                // Keep button state as "Share Drawing"
                drawButton.textContent = 'Share Drawing';
            });

             map.on(L.Draw.Event.DRAWSTART, function (event) {
                // Clear previous local drawing when starting a new one
                if (localDrawingLayer) {
                    drawnItems.removeLayer(localDrawingLayer);
                    localDrawingLayer = null;
                }
                 drawButton.textContent = 'Share Drawing'; // Ensure text is correct
                 console.log("Drawing started.");
             });

            map.on(L.Draw.Event.DRAWSTOP, function(event) {
                // If drawing stops without creating anything (e.g., escape key),
                // revert button state if no local drawing exists
                if (!localDrawingLayer) {
                    drawButton.textContent = 'Start Drawing';
                }
                 console.log("Drawing stopped.");
            });

            map.on(L.Draw.Event.EDITED, function (event) {
                 // If you allow editing, you might want to re-share or update
                 console.log("Local drawing edited.");
                 // For now, require clicking share again after edit
                 drawButton.textContent = 'Share Drawing';
             });
        }

    </script>
    </body>
</html>

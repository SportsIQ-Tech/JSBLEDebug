<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KaiTag AR15 & GPS Map</title>
    <!-- Add Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
     integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
     crossorigin=""/>
        <style>
        body { margin: 0; overflow: hidden; background-color: #111; color: #fff; font-family: monospace; display: flex; flex-direction: column; height: 100vh; }
        #top-container {
            flex: 1; /* Take up remaining space */
            position: relative; /* For positioning button/status inside */
            overflow: hidden; /* Ensure canvas doesn't overflow */
            min-height: 50%; /* Minimum height */
        }
        #bottom-container {
            flex: 1; /* Take up remaining space */
            min-height: 50%; /* Minimum height */
            border-top: 1px solid #555; /* Separator line */
        }
        #map {
             height: 100%;
             width: 100%;
             background-color: #333; /* Placeholder background */
        }
        /* Adjust canvas style if needed, Three.js usually handles this */
        #top-container canvas { display: block; }

        #gps-info { display: none; } /* Hide old GPS text */

        #connect-button {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px 15px;
            font-size: 16px;
            cursor: pointer;
            background-color: #444;
            border: none;
            border-radius: 5px;
            color: #fff;
            z-index: 10; /* Ensure button is on top of canvas */
        }
        #status {
             position: absolute;
             bottom: 10px;
             left: 10px;
             padding: 5px 10px;
             background-color: rgba(0, 0, 0, 0.5);
             border-radius: 5px;
             font-size: 14px;
             z-index: 10; /* Ensure status is on top of canvas */
        }
        </style>
    </head>
    <body>
    <!-- Containers for split view -->
    <div id="top-container">
        <!-- Connect button and status moved inside top container -->
        <button id="connect-button">Connect KaiTag</button>
        <div id="status">Status: Disconnected</div>
        <!-- Canvas will be added here by Three.js -->
    </div>
    <div id="bottom-container">
        <div id="map"></div>
    </div>

    <!-- Old GPS Info Div (hidden by CSS) -->
    <div id="gps-info">GPS: Acquiring...</div>

     <!-- Add Leaflet JS -->
     <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
     integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
     crossorigin=""></script>

    <!-- Add Socket.IO Client Library -->
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"
    integrity="sha384-2huaZvOR9iDzHqslqwpR87isEmrfxqyWOF7hr7BY6KG0+hVKLoEXMPUJw3ynWuhO"
    crossorigin="anonymous"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Constants ---
        const SERVICE_UUID = 'b7063e97-8504-4fcb-b0f5-aef2d5903c4d';
        const QUATERNION_CHARACTERISTIC_UUID = '71fa0f31-bcc7-42f2-bb57-a9810b436231';

        // --- DOM Elements ---
        // const gpsInfoDiv = document.getElementById('gps-info'); // No longer used directly
        const connectButton = document.getElementById('connect-button');
        const statusDiv = document.getElementById('status');
        const topContainer = document.getElementById('top-container');
        const mapContainer = document.getElementById('map');

        // --- State ---
        let device = null;
        let quaternionCharacteristic = null;
        let ar15Model = null;
        let scene = null;
        let camera = null;
        let renderer = null;
        const targetQuaternion = new THREE.Quaternion();
        const displayQuaternion = new THREE.Quaternion();
        let map = null; // Leaflet map instance
        let localGpsMarker = null; // Leaflet marker instance for the LOCAL user
        let otherClientMarkers = {}; // { clientId: { marker: L.Marker, line: L.Polyline }, ... }
        let firstGpsUpdate = true;
        const lineDistanceMeters = 500; // How long the direction line should be
        const forwardVector = new THREE.Vector3(); // Reusable vector for direction calculation
        let socket = null; // Changed from webSocket
        let myClientId = null;
        let clientStates = {}; // { clientId: { lat: number, lon: number, bearing: number, timestamp: number }, ... }
        // No WS_URL needed when served from same origin

        // Throttling for bearing updates
        let lastBearingSendTime = 0;
        let lastSentBearing = -1; // Initialize to impossible value
        const bearingUpdateThreshold = 1.0; // Degrees
        const bearingUpdateInterval = 100; // Milliseconds (10 times per second max)

        // --- WebSocket Communication ---
        function connectSocketIO() {
             // Connect to the Socket.IO server (same origin)
             socket = io(); // If server is elsewhere: io('http://server.com:port');

             socket.on('connect', () => {
                 console.log('Socket.IO Connected, SID:', socket.id);
                 statusDiv.textContent = 'Status: Connected';
                 // Client ID is now socket.id, but wait for 'your_id' message
                 // just in case server uses a different ID system
             });

             socket.on('disconnect', (reason) => {
                 console.log('Socket.IO Disconnected:', reason);
                 statusDiv.textContent = 'Status: Disconnected';
                 myClientId = null;
                 // Clear other clients from map
                 Object.values(otherClientMarkers).forEach(({ marker, line }) => {
                     if (map && marker) map.removeLayer(marker);
                     if (map && line) map.removeLayer(line);
                 });
                 otherClientMarkers = {};
                 clientStates = {};
             });

             socket.on('connect_error', (error) => {
                 console.error('Socket.IO Connection Error:', error);
                 statusDiv.textContent = 'Status: Connection Error';
             });

             // --- Custom Event Handlers ---
             socket.on('your_id', (id) => {
                 myClientId = id;
                 console.log('My Client ID:', myClientId);
             });

             socket.on('all_states', (states) => {
                 // console.log('Received all_states:', states);
                 clientStates = states;
                 updateMapMarkers(); // Redraw map based on new states
             });

             socket.on('client_disconnected', (disconnectedId) => {
                  console.log(`Client disconnected event: ${disconnectedId}`);
                  // Remove the specific client (map update handled by 'all_states' usually,
                  // but we can explicitly remove here too for faster feedback)
                  if (otherClientMarkers[disconnectedId]) {
                     if(map && otherClientMarkers[disconnectedId].marker) map.removeLayer(otherClientMarkers[disconnectedId].marker);
                     if(map && otherClientMarkers[disconnectedId].line) map.removeLayer(otherClientMarkers[disconnectedId].line);
                     delete otherClientMarkers[disconnectedId];
                     console.log(`Removed disconnected client ${disconnectedId} marker/line`);
                  }
                  // State update will come via next 'all_states' broadcast
             });

             socket.on('bearing_updated', (update) => {
                 // console.log('Received bearing_updated:', update);
                 const { clientId, bearing, timestamp } = update;
                 if (clientStates[clientId]) {
                     clientStates[clientId].bearing = bearing;
                     clientStates[clientId].timestamp = timestamp; // Use server timestamp
                     // Update map (could optimize to only update the specific client's line)
                     updateMapMarkers();
                 } else {
                     console.warn('Received bearing update for unknown client:', clientId);
                     // Request full state? Or wait for next all_states broadcast.
                 }
             });
         }

        function sendSocketIOMessage(type, payload) {
            if (socket && socket.connected) {
                // console.log('Emitting Socket.IO message:', type, payload);
                socket.emit(type, payload);
            } else {
                console.warn('Socket.IO not connected. Message not sent:', type);
            }
        }

        // --- Helper: Calculate Destination Point ---
        function calculateDestinationPoint(lat1, lon1, bearing, distance) {
            const R = 6371e3; // Earth radius in meters
            const phi1 = lat1 * Math.PI / 180; // φ, λ in radians
            const lambda1 = lon1 * Math.PI / 180;
            const brng = bearing * Math.PI / 180;
            const d = distance;

            const phi2 = Math.asin(Math.sin(phi1) * Math.cos(d / R) +
                                 Math.cos(phi1) * Math.sin(d / R) * Math.cos(brng));
            const lambda2 = lambda1 + Math.atan2(Math.sin(brng) * Math.sin(d / R) * Math.cos(phi1),
                                           Math.cos(d / R) - Math.sin(phi1) * Math.sin(phi2));

            const lat2 = phi2 * 180 / Math.PI;
            const lon2 = lambda2 * 180 / Math.PI;

            return [lat2, lon2];
        }

        // --- Helper: Get Local Bearing ---
        function getLocalBearing() {
             if (!ar15Model) return 0; // Default bearing

            // 1. Get Gun's World Direction
            ar15Model.getWorldDirection(forwardVector); // Updates forwardVector

            // 2. Calculate Azimuth
            const azimuth = Math.atan2(forwardVector.x, forwardVector.z);

            // 3. Convert Azimuth to Bearing
            let bearing = azimuth * (180 / Math.PI);
            bearing = (bearing + 360) % 360; // Normalize to 0-359 degrees
            // Adjust bearing offset if needed here based on model orientation vs North
            return bearing;
        }

        // --- Helper: Update Map Markers and Lines (All Clients) ---
        function updateMapMarkers() {
            if (!map || !myClientId) return; // Need map and our ID

            const currentOtherIds = new Set(Object.keys(otherClientMarkers));

            for (const clientId in clientStates) {
                const state = clientStates[clientId];
                const latLng = L.latLng(state.lat, state.lon);
                const endPointLatLng = calculateDestinationPoint(state.lat, state.lon, state.bearing, lineDistanceMeters);
                const isLocal = (clientId === myClientId);

                if (isLocal) {
                    // Update local marker and line (create if they don't exist)
                    if (!localGpsMarker) {
                         localGpsMarker = L.circleMarker(latLng, {
                            radius: 8, fillColor: "#00ff00", color: "#000",
                            weight: 1, opacity: 1, fillOpacity: 0.8
                         }).addTo(map).bindPopup("You");
                         // Create local direction line associated with marker
                         localGpsMarker.directionLine = L.polyline([latLng, endPointLatLng], {
                            color: '#00ff00', weight: 3
                         }).addTo(map);
                    } else {
                        localGpsMarker.setLatLng(latLng);
                        localGpsMarker.directionLine.setLatLngs([latLng, endPointLatLng]);
                    }
                    // Center map on local user on first GPS update
                    if (firstGpsUpdate) {
                        map.setView(latLng, 15);
                        firstGpsUpdate = false;
                        console.log("Local GPS Acquired, centering map.");
                    }

                } else {
                    // Update other client marker and line
                    if (otherClientMarkers[clientId]) {
                        // Existing other client
                        otherClientMarkers[clientId].marker.setLatLng(latLng);
                        otherClientMarkers[clientId].line.setLatLngs([latLng, endPointLatLng]);
                    } else {
                        // New other client
                        const marker = L.circleMarker(latLng, {
                            radius: 6, fillColor: "#0000ff", color: "#000", // Blue
                            weight: 1, opacity: 1, fillOpacity: 0.7
                        }).addTo(map).bindPopup(`Client ${clientId.substring(0, 6)}`);

                        const line = L.polyline([latLng, endPointLatLng], {
                            color: '#0000ff', weight: 3 // Blue
                        }).addTo(map);
                        otherClientMarkers[clientId] = { marker, line };
                        console.log(`Added other client ${clientId} to map`);
                    }
                    currentOtherIds.delete(clientId); // Mark this ID as still present
                }
            }

             // Remove markers for clients that are no longer in clientStates
            currentOtherIds.forEach(clientIdToRemove => {
                if (otherClientMarkers[clientIdToRemove]) {
                    map.removeLayer(otherClientMarkers[clientIdToRemove].marker);
                    map.removeLayer(otherClientMarkers[clientIdToRemove].line);
                    delete otherClientMarkers[clientIdToRemove];
                    console.log(`Removed stale client ${clientIdToRemove} from map`);
                }
            });
        }

        // --- 3D Setup ---
        function initThreeJS() {
            scene = new THREE.Scene();

            // Get dimensions of the top container
            const width = topContainer.clientWidth;
            const height = topContainer.clientHeight;

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            topContainer.appendChild(renderer.domElement); // Append canvas to top container

            // Lighting (Increased intensity)
            const ambientLight = new THREE.AmbientLight(0x404040, 3);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.0);
            directionalLight.position.set(1, 1, 1).normalize();
            scene.add(directionalLight);
            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight2.position.set(-1, -1, -1).normalize();
            scene.add(directionalLight2);

            // Load AR15 Model
            const loader = new GLTFLoader();
            const modelPath = 'models/ar15.glb';
            loader.load(
                modelPath,
                function (gltf) {
                    ar15Model = gltf.scene;
                    console.log(`Loaded ${modelPath}`);
                    // Adjust scale and position
                    ar15Model.scale.set(10, 10, 10); // Scale from previous step
                    ar15Model.position.set(0, 0, 0);
                    scene.add(ar15Model);
                    console.log('Model added to scene.');
                },
                undefined,
                function (error) {
                    console.error(`Error loading ${modelPath}:`, error);
                    statusDiv.textContent = `Status: Error loading 3D model! Check console.`;
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = new THREE.MeshStandardMaterial({color: 0xdddddd});
                    ar15Model = new THREE.Mesh(geometry, material);
                    scene.add(ar15Model);
                    console.log('Placeholder cube added due to load error.');
                }
            );

            camera.position.z = 10; // Keep camera distance
            console.log('Camera position:', camera.position);

            animate();
            // Note: Resize handled by global window resize listener
        }

        // --- Map Setup ---
        function initMap() {
            const initialCoords = [0, 0];
            map = L.map(mapContainer).setView(initialCoords, 2);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
            }).addTo(map);

            // Markers and lines are now created/updated dynamically in updateMapMarkers
            console.log("Map initialized");
        }

        function onWindowResize() {
             // Update 3D view
             if (camera && renderer && topContainer) {
                const width = topContainer.clientWidth;
                const height = topContainer.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
                console.log("Resized 3D view");
             }

            // Update map view
            if (map) {
                map.invalidateSize(); // Recalculate map size
                console.log("Resized map view");
            }
        }
        window.addEventListener('resize', onWindowResize, false);

        function animate() {
            requestAnimationFrame(animate);

            let modelRotated = false;
            let currentBearing = 0;
            if (ar15Model) {
                // Smoothly interpolate the model's rotation
                displayQuaternion.slerp(targetQuaternion, 0.1);
                // Apply base rotation if needed (adjust based on your model)
                const baseOrientation = new THREE.Quaternion() //.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2);
                const finalQuaternion = baseOrientation.multiply(displayQuaternion);
                ar15Model.setRotationFromQuaternion(finalQuaternion);
                modelRotated = true;
                currentBearing = getLocalBearing(); // Get bearing after rotation
            }

            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }

            // Update LOCAL direction line directly based on latest bearing
            let localLineUpdated = false;
            if (modelRotated && localGpsMarker && localGpsMarker.directionLine) {
                const startPoint = localGpsMarker.getLatLng();
                if (startPoint) { // Ensure we have a valid LatLng
                    const endPointLatLng = calculateDestinationPoint(startPoint.lat, startPoint.lng, currentBearing, lineDistanceMeters);
                    localGpsMarker.directionLine.setLatLngs([ [startPoint.lat, startPoint.lng], endPointLatLng ]);
                    localLineUpdated = true;
                }
            }

            // Throttle sending bearing updates via Socket.IO
            const now = Date.now();
            if (modelRotated && socket && socket.connected && myClientId &&
                (Math.abs(currentBearing - lastSentBearing) > bearingUpdateThreshold || lastSentBearing < 0) && // Bearing changed enough or first time
                (now - lastBearingSendTime > bearingUpdateInterval) ) // Enough time passed
            {
                socket.emit('update_bearing', currentBearing);
                lastSentBearing = currentBearing;
                lastBearingSendTime = now;
                // console.log(`Sent bearing update: ${currentBearing.toFixed(1)}`);
            }
        }

        // --- GPS ---
        function initGPS() {
            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(
                    (position) => {
                        const lat = position.coords.latitude;
                        const lon = position.coords.longitude;
                        const bearing = getLocalBearing(); // Get current bearing

                        // Send local state update to server
                        sendSocketIOMessage('update_state', {
                            lat: lat,
                            lon: lon,
                            bearing: bearing
                            // timestamp: Date.now() // Optional: server can handle this
                        });

                        // Update local state immediately for responsiveness (server will echo back)
                        if(myClientId) {
                             if (!clientStates[myClientId]) clientStates[myClientId] = {};
                             clientStates[myClientId].lat = lat;
                             clientStates[myClientId].lon = lon;
                             clientStates[myClientId].bearing = bearing;
                             clientStates[myClientId].timestamp = Date.now();
                             updateMapMarkers(); // Update map immediately with local change
                        }

                    },
                    (error) => {
                        statusDiv.textContent = `Status: GPS Error - ${error.message}`;
                        console.error("Geolocation error:", error);
                    },
                    {
                        enableHighAccuracy: true, // Keep high accuracy
                        maximumAge: 5000,      // Don't use old positions > 5s
                        timeout: 10000         // Give up after 10s
                    }
                );
            } else {
                statusDiv.textContent = "Status: GPS not supported";
                console.error("Geolocation not supported by this browser.");
            }
        }

        // --- BLE ---
        async function connectDevice() {
            try {
                statusDiv.textContent = 'Status: Requesting device...';
                device = await navigator.bluetooth.requestDevice({
                     filters: [{name: 'KaiTag'}],
                     optionalServices: [SERVICE_UUID]
                });
                statusDiv.textContent = `Status: Connecting to ${device.name}...`;
                device.addEventListener('gattserverdisconnected', onDisconnected);
                const server = await device.gatt.connect();
                statusDiv.textContent = 'Status: Getting Service...';
                const service = await server.getPrimaryService(SERVICE_UUID);
                statusDiv.textContent = 'Status: Getting Characteristic...';
                quaternionCharacteristic = await service.getCharacteristic(QUATERNION_CHARACTERISTIC_UUID);
                statusDiv.textContent = 'Status: Starting Notifications...';
                await quaternionCharacteristic.startNotifications();
                quaternionCharacteristic.addEventListener('characteristicvaluechanged', handleCharacteristicValueChanged);
                statusDiv.textContent = `Status: Connected to ${device.name}`;
                connectButton.textContent = 'Disconnect';
                console.log('Connected to KaiTag');
            } catch (error) {
                statusDiv.textContent = `Status: Error - ${error.message}`;
                console.error('BLE Connection Error:', error);
                if (device) {
                    device.removeEventListener('gattserverdisconnected', onDisconnected);
                    if (device.gatt.connected) {
                        device.gatt.disconnect();
                    }
                }
                device = null;
                quaternionCharacteristic = null;
                 connectButton.textContent = 'Connect KaiTag';
            }
        }

        function onDisconnected() {
            statusDiv.textContent = 'Status: Disconnected';
            console.log('Device disconnected');
            if (quaternionCharacteristic) {
                quaternionCharacteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicValueChanged);
            }
            if(device) { // Check if device exists before removing listener
                 device.removeEventListener('gattserverdisconnected', onDisconnected);
            }
            device = null;
            quaternionCharacteristic = null;
            connectButton.textContent = 'Connect KaiTag';
             // Reset target orientation
             targetQuaternion.set(0, 0, 0, 1);
        }

        async function disconnectDevice() {
            if (!device || !device.gatt.connected) return;
            statusDiv.textContent = 'Status: Disconnecting...';
            try {
                if (quaternionCharacteristic && quaternionCharacteristic.properties.notify) {
                    await quaternionCharacteristic.stopNotifications();
                    quaternionCharacteristic.removeEventListener('characteristicvaluechanged', handleCharacteristicValueChanged);
                     console.log('Stopped characteristic notifications.');
                 }
                device.gatt.disconnect(); // onDisconnected will handle the rest
            } catch(error) {
                statusDiv.textContent = `Status: Error disconnecting - ${error.message}`;
                console.error('BLE Disconnect Error:', error);
                onDisconnected();
            }

        }

        function handleCharacteristicValueChanged(event) {
            const value = event.target.value;
             if (value.byteLength >= 16) {
                 try {
                    const w = value.getFloat32(0, true);
                    const x = value.getFloat32(4, true);
                    const y = value.getFloat32(8, true);
                    const z = value.getFloat32(12, true);
                     targetQuaternion.set(x, y, z, w).normalize();
                 } catch (e) {
                     console.error("Error parsing quaternion data:", e);
                 }
            } else {
                 console.warn(`Received data length ${value.byteLength} is less than expected 16 bytes for quaternion.`);
             }
        }

        // --- Event Listeners ---
        connectButton.addEventListener('click', () => {
            if (device && device.gatt.connected) {
                disconnectDevice();
            } else {
                connectDevice();
            }
        });

        // --- Initialization ---
        initMap();
        initThreeJS();
        initGPS();
        connectSocketIO(); // Connect Socket.IO after setting up UI

        </script>
    </body>
</html>
